<?php
/**
 * @file
 * Defines reports generated by or used by SmartDocs.
 */

use Apigee\ManagementAPI\Organization;
use Apigee\SmartDocs\Model;
use Apigee\SmartDocs\Revision;

/**
 * Generates and displays the node status report for SmartDocs.
 *
 * The first time this function is called, it creates a batch to gather
 * integrity-check data for the report. At the end of the batch run, the batch
 * results are stored in $_SESSION and the function is called again to display
 * the resulting report.
 *
 * @return string
 */
function smartdocs_node_status_report() {
  // Are we in report-generate or report-display mode?
  if (!isset($_SESSION['orphan_report_results'])) {
    // First, check to see if we're configured correctly with the API.
    $can_connect = FALSE;
    $config = devconnect_default_org_config();
    if (!empty($config->orgName)) {
      $org = new Organization($config);
      try {
        $org->load($config->orgName);
        $can_connect = TRUE;
      }
      catch (Exception $e) {
      }
    }
    if (!$can_connect) {
      return t('Cannot connect to the Modeling API. Please check your <a href="!url">configuration settings</a>.', array('!url' => url('admin/config/devconnect')));
    }

    // Generate a big hairy query. This is still faster than doing an
    // entity_load_multiple on nodes of a particular bundle.
    $query = db_select('node', 'n');
    $query->innerJoin('node_revision', 'r', 'n.nid = r.nid');
    $query->innerJoin('field_data_field_smart_method_model', 'mm', 'r.vid = mm.revision_id');
    $query->innerJoin('taxonomy_term_data', 't', 'mm.field_smart_method_model_tid = t.tid');
    $query->innerJoin('field_revision_field_smart_method_revision_num', 'mr', 'r.vid = mr.revision_id');
    $query->innerJoin('field_revision_field_smart_method_resource_uuid', 'ms', 'r.vid = ms.revision_id');
    $query->innerJoin('field_revision_field_smart_method_uuid', 'mt', 'r.vid = mt.revision_id');

    $query->fields('n', array('nid', 'title', 'status'));
    $query->addExpression('t.name', 'model');
    $query->addExpression('mr.field_smart_method_revision_num_value', 'revision');
    $query->addExpression('ms.field_smart_method_resource_uuid_value', 'resource');
    $query->addExpression('mt.field_smart_method_uuid_value', 'method');

    $query->condition('n.type', 'smart_method');

    $result = $query->execute();
    $models = array();
    foreach ($result as $row) {
      // Sort by model and revision, so we can optimize API queries.
      $models[$row->model][$row->revision][] = $row;
    }

    // Begin creating the batch that validates each node.
    $operations = array();
    foreach ($models as $model => $revision_info) {
      foreach ($revision_info as $revision => $methods) {
        $operations[] = array('smartdocs_validate_model_revision', array($model, $revision, $methods));
      }
    }

    $batch = array(
      'title' => t('Preparing SmartDocs node status report'),
      'operations' => $operations,
      'finished' => 'smartdocs_node_status_report_finished',
      'init_message' => t('Validating has started...'),
      'progress_message' => t('Processed @current out of @total.'),
      'error_message' => t('Validation of SmartDocs nodes has encountered an error.'),
      'file' => drupal_get_path('module', 'smartdocs') . '/smartdocs.reports.inc',
    );
    batch_set($batch);
    batch_process('admin/reports/smartdocs');
    return;
  }

  // Display the report.
  $results = $_SESSION['orphan_report_results'];
  unset($_SESSION['orphan_report_results']);
  if (empty($results)) {
    // No errors were encountered, so we're all good.
    return t('All SmartDocs nodes correspond correctly to methods on the Modeling API.');
  }
  // Found issues, so report them in a list.
  $output = '<p>' . t('The following problems were encountered when validating methods against the Modeling API:') . '</p>'
    . theme('item_list', array('items' => $results));

  return $output;
}

/**
 * Validates that all methods that claim to be in a revision are reachable.
 *
 * @param string $model
 *   The machine-name of the model being validated.
 * @param int $revision
 *   The revision within the model to validate.
 * @param array $methods
 *   List of stdClass objects representing methods to be validated.
 * @param array $context
 *   The current batch context.
 */
function smartdocs_validate_model_revision($model, $revision, $methods, array &$context) {
  $revision_obj = FALSE;
  $model_obj = FALSE;
  $attempted_model_load = FALSE;

  // Don't do logging while trying to validate nodes.
  $config = devconnect_default_org_config();
  $config->logger = new Psr\Log\NullLogger();
  $config->subscribers = array();

  // Load the revision. Use optimized functionality if it exists.
  if (function_exists('smartdocs_proxy_load_model_hierarchy')) {
    $model_obj = smartdocs_proxy_load_model_hierarchy($model, $revision);
    $attempted_model_load = TRUE;
    if ($model_obj) {
      $active_revision = $model_obj->getActiveRevision();
      if ($active_revision instanceof Revision && $active_revision->getRevisionNumber() == $revision) {
        $revision_obj = $active_revision;
      }
    }
  }
  else {
    try {
      $active_revision = new Revision($config, $model, $revision);
      $active_revision->load($revision);
      $revision_obj = $active_revision;
    }
    catch (Exception $e) {
    }
  }

  if (!$revision_obj) {
    // If the revision failed to load, it's possible that it's because the
    // model doesn't exist. If we did not already try to load the model, do so
    // now, to see if that is the problem.
    if (!$attempted_model_load) {
      try {
        $model_obj = new Model($config);
        $model_obj->load($model);
      }
      catch (Exception $e) {
      }
    }
    // Is the model present?
    if (!($model_obj instanceof Model) || $model_obj->getName() == '') {
      foreach ($methods as $method) {
        $context['results'][] = t('Cannot find model %model corresponding to method !method.', array(
            '!method' => l($method->title, 'node/' . $method->nid),
            '%model' => $model,
          ));
      }
      $context['message'] = t('Found invalid model %model.', array('%model' => $model));
    }
    // We got the model, so the revision must be the bad link.
    else {
      foreach ($methods as $method) {
        $context['results'][] = t('In method !method, cannot find revision %rev in model %model.', array(
            '%rev' => $revision,
            '!method' => l($method->title, 'node/' . $method->nid),
            '%model' => $model,
          ));
      }
      $context['message'] = t('Found invalid revision for model %model.', array('%model' => $model));
    }
    // Short-circuit this batch operation.
    return;
  }

  // We have a valid revision, so let's validate the resource and method for
  // each node belonging to that revision.
  $resources = $revision_obj->getResources();
  foreach ($methods as $method) {
    $found_resource = $found_method = FALSE;
    foreach ($resources as $resource) {
      if ($resource->getUuid() == $method->resource) {
        $found_resource = TRUE;
        foreach ($resource->getMethods() as $method_obj) {
          if ($method_obj->getUuid() == $method->method) {
            $found_method = TRUE;
            break;
          }
        }
        break;
      }
    }
    if (!$found_resource) {
      $context['results'][] = t('Cannot find resource %res in revision %rev for method !method in model %model.', array('%res' => $method->resource, '%rev' => $revision, '!method' => l($method->title, 'node/' . $method->nid), '%model' => $model));
    }
    elseif (!$found_method) {
      $context['results'][] = t('Cannot find method %method in revision %rev for method !method in model %model.', array('%method' => $method->method, '%rev' => $revision, '!method' => l($method->title, 'node/' . $method->nid), '%model' => $model));
    }
    // Don't bother setting a results message for valid methods.
  }
  $context['message'] = t('Validated revision %rev of model %model', array('%rev' => $revision, '%model' => $model));
}

/**
 * Batch-finished callback for the node status report.
 *
 * @param bool $success
 *   Did we finish without errors?
 * @param $results
 *   List of results set in the batch context by its operations.
 * @param $operations
 *   List of operations that were performed.
 */
function smartdocs_node_status_report_finished($success, $results, $operations) {
  // Set results array in the session to be displayed on the report.
  $_SESSION['orphan_report_results'] = $results;
}
